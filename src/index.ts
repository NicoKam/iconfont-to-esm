import got from 'got';
import fs from 'fs';
import { parse } from 'acorn';
import * as htmlparser2 from 'htmlparser2';
import { camelCase } from 'change-case';
import logger from './logger.js';
import { ancestor } from 'acorn-walk';
import argv from './argv.js';

const comment = `/* eslint-disable */
/* This file was generated by iconfont-to-react-svg. Do not modify. */
`

export default async function main() {
  const [url] = argv._;
  const target = argv.target || './icons.ts';
  if (!url) {
    logger.error('请指定 iconfont 的 url 地址');
    process.exit(1);
  }
  // load url
  const resp = await got(url);
  if (resp.statusCode === 200) {
    const script = resp.body;

    // parse script
    const ast = parse(script, {
      ecmaVersion: 2016,
    });

    let svgString = '';

    ancestor(ast, {
      AssignmentExpression(node: any) {
        if (node.type === 'AssignmentExpression') {
          if (
            node.left.type === 'MemberExpression' &&
            node.left.object?.name == 'window' &&
            node.left.property?.name?.startsWith('_iconfont_')
          ) {
            svgString = node.right.value;
          }
        }
      },
    });

    if (!svgString) {
      logger.error(`未能从 ${url} 中识别到 iconfont 信息，请检查识别规则`);
      process.exit(1);
    }

    const dom = htmlparser2.parseDocument(svgString);

    const svgRoot = dom.firstChild;

    if (!svgRoot || svgRoot.type !== 'tag' || svgRoot.name !== 'svg') {
      logger.error(`未能从 ${url} 解析到 <svg> 标签，请检查识别规则`);
      process.exit(1);
    }

    const icons = svgRoot.children
      .map((node) => {
        if (node.type === 'tag' && node.name === 'symbol') {
          const id = node.attribs.id;
          const viewBox = node.attribs.viewbox;
          const paths = node.children
            .map((path) => {
              if (path?.type === 'tag') {
                if (path.name === 'path') {
                  return path.attribs;
                } else {
                  logger.warn('非 path 类型:', path, id);
                }
              } else {
                logger.warn('未知类型:', path, id);
              }
            })
            .filter((v) => !!v);

          return {
            id,
            viewBox,
            paths,
          };
          // const path = node.children[0].attribs.d;
          // console.log(`export const ${id} = {viewBox: '${viewBox}', path: '${path}'}`)
        }
        return null;
      })
      .filter((v) => !!v);

    const repeat: Record<string, number> = {};
    const iconNameList: string[] = [];
    // 生成文件
    const iconFileContent = icons
      .reverse()
      .map((icon) => {
        const { id, paths, viewBox } = icon!;
        let name = camelCase(id.toLocaleLowerCase());
        const r = repeat[name] || 0;
        if (r > 0) {
          logger.warn(`重复的 icon name: ${name} <-- ${id}`);
          name += r;
        }
        repeat[name] = r + 1;
        iconNameList.push(name);
        return `export const ${name} = { name: '${name}', viewBox: '${viewBox}', paths: ${JSON.stringify(paths)} };`;
      })
      .reverse()
      .join('\n\n');

    // 寫入文件
    fs.writeFileSync(
      target,
      `${comment}
${iconFileContent}

export const iconList = [${iconNameList.join(', ')}];`,
    );

    logger.success(`已生成 ${target} 共 ${iconNameList.length} 个 icon`);
    // fs.writeFileSync('icons.json', JSON.stringify(icons, null, 2));
    // fs.writeFileSync('ast.json', JSON.stringify(ast, null, 2));
  } else {
    logger.error(`Failed to load url(${resp.statusCode}): ${url}`);
  }
}
